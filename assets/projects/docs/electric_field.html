<!DOCTYPE html>
<html lang="en" translate="no">
    <head>
        <title>EmptyHead | Projects</title>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        
        <link rel="icon" type="image/png" href="../../../assets/images/favicon.png" sizes="32x32" />
        
        <meta property="og:title" content="EmptyHead" />
        <meta property="og:description" content="Welcome to my corner of the web! A place where I share my projects, experiments, and random ideas as I learn and grow as a developer." />
        <meta property="og:url" content="https://www.emptyhead.dev/" />
        <meta property="og:type" content="website" />
        <meta property="og:site_name" content="EmptyHead" />
        <meta property="og:locale" content="en_US" />
        <meta property="og:site" content="https://www.emptyhead.dev/" />
        <meta property="og:locale:alternate" content="en_US" />
        <meta property="og:locale:alternate" content="en_GB" />
        <meta property="og:locale:alternate" content="it_IT" />
        <meta property="og:image" content="../../../assets/images/banner.webp">

        <meta name="description" content="Welcome to my corner of the web! A place where I share my projects, experiments, and random ideas as I learn and grow as a developer." />
        <meta name="keywords" content="EmptyHead, marick, portfolio, projects, web development, programming" />
        <meta name="author" content="marick" />
        
        <link rel="stylesheet" href="../../../assets/css/projects_docs.css" />

        <link rel="stylesheet" href="../../../assets/css/variables.css" />
        <link rel="stylesheet" href="../../../assets/css/loading-screen.css" />
        <link rel="stylesheet" href="../../../assets/css/header.css" />
        <link rel="stylesheet" href="../../../assets/css/menu.css" />
        <link rel="stylesheet" href="../../../assets/css/footer.css" />

        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.7.2/css/all.min.css" integrity="sha512-Evv84Mr4kqVGRNSgIGL/F/aIDqQb7xQ2vcrdIwxfjThSH8CSR7PBEakCr51Ck+w+/U6swU2Im1vVX0SVk9ABhg==" crossorigin="anonymous" referrerpolicy="no-referrer" />
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/monokai.min.css">

    </head>

    <body class="loading">
        <div id="loading-screen">
            <div class="spinner"></div>
        </div>
        
        <!-- Header -->
        <header id="global-header" class="header scrolled">
            <div class="logo"><a href="/">EmptyHead <span class="by">by marick</span></a></div>
            <button id="menu-toggle" class="menu-toggle"><i class="fa-solid fa-bars"></i></button>
        </header>

        <!-- Nav -->
		<div class="overlay"></div>
        <nav id="menu">
            <ul id="menu-buttons" class="links">
                <li><a href="/" class="home-button"><i class="fas fa-home"></i>  Home</a></li>
                <li><a href="aboutme.html" class="about-button"><i class="fas fa-info-circle"></i>  About Me</a></li>
                <li><a href="myprojects.html" class="projects-button"><i class="fas fa-folder-open"></i>  My Projects</a></li>
                <li><a href="#" class="contact-button"><i class="fas fa-envelope"></i>  Contact</a></li>
                <li><a href="https://ko-fi.com/N4N01FXMFF" class="support-button" target="_blank" rel="noopener"><i class="fas fa-heart"></i>  Support Me</a></li>
            </ul>

			<!-- Counter -->
			<div id="stats-panel" class="stats">
				<h3 id="counter-title">Visits stats (Loading...)</h3>

				<div class="stat-item">
					<span class="label">Today</span>
					<span class="value-with-diff">
						<span class="value" id="today-count">0</span>
						<span class="diff" id="today-diff">
							<span id="today-diff-count">(+0)</span>
							<i id="today-diff-arrow" class="fas fa-arrow-up"></i>
						</span>
					</span>
				</div>

				<div class="stat-item">
					<span class="label">Yesterday</span>
					<span class="value" id="yesterday-count">0</span>
				</div>

				<div class="stat-item">
					<span class="label">This Week</span>
					<span class="value" id="week-count">0</span>
				</div>

				<div class="stat-item">
					<span class="label">This Month</span>
					<span class="value" id="month-count">0</span>
				</div>

				<div class="stat-item total-total">
					<span class="label">Total</span>
					<span class="value" id="total-count">0</span>
				</div>
			</div>
		</nav>

        <!-- Local-Header -->
        <div class="header-bg"><header id="local-header" class="header">
            <div class="logo"><a href="/">EmptyHead <span class="by">by marick</span></a></div>
            <button id="menu-toggle" class="menu-toggle"><i class="fas fa-bars"></i></button>
        </header></div>

        <!-- Content -->
        <section class="project-section">
            <div class="project-content">
                
                <h1>2D Electric Field Line Simulator</h1>
                <p class="project-meta">
                    <span class="project-id">Project #236</span>
                    <span class="project-date">Published: 02/06/2025</span>
                </p>


                <p>
                    This simulation demonstrates the behavior of electric field lines generated by multiple point charges.
                    Built on top of <scode>e2D</scode>, it uses real-time computation and efficient rendering to visualize
                    the invisible electric interactions that govern charged particles.
                </p>

                <video controls poster="../../../assets/images/projects/electric_field/electric_field_screenshot_2025_06_02_21_07_52.webp" class="project-video">
                    <source src="../../../assets/videos/projects/electric_field/efield.webm" type="video/webm">
                    Your browser does not support the video tag.
                </video>

                <h2>üîë Key Features</h2>
                <ul>
                    <li>Real-time field line tracing using <em>Euler integration</em></li>
                    <li>Custom charge distribution using analytical skewed functions</li>
                    <li>JIT-compiled vectorized physics core with <scode>Numba</scode></li>
                    <li>Interactive: drag charges, add orbs, change parameters on the fly</li>
                    <li>Screenshot system with timestamp</li>
                </ul>

                <h2>üïπÔ∏è Controls Overview</h2>
                <pre><code class="text">quit / close window         - X or Alt+F4
move selected charge        - LEFT CLICK + DRAG
select charge               - LEFT CLICK
change selected charge ¬±0.1 - UP / DOWN ARROW
change selected charge ¬±1   - RIGHT / LEFT ARROW
toggle keybinds             - Q
toggle cut line on edge     - W
randomize field origins     - E
center origins on positives - R
reset charges to start pos  - T
randomize charge positions  - Y
randomize charge values     - A
take screenshot             - S
toggle advanced colors      - D
add + charged orb at mouse  - F
add - charged orb at mouse  - G</code></pre>

                <h2>üé® Advanced Color Modes (D to toggle)</h2>
                <p>
                    The simulator supports two color modes for field lines:
                </p>
                <ul>
                    <li><strong>Advanced Colors <em>(left)</em>:</strong> Field lines are colored using a <em>continuous gradient</em> based on local field strength and polarity, producing a vivid, informative visualization.</li>
                    <li><strong>Low Spec Mode <em>(right)</em>:</strong> Field lines use a simple <em>two-tone</em> color scheme for <em>maximum performance</em> and clarity on lower-end hardware.</li>
                </ul>
                <img src="../../../assets/images/projects/electric_field/electric_field_screenshot_2025_06_02_22_51_12.webp" alt="Advanced Colors vs Low Spec Mode" class="project-image"/>

                <h2>üß† Understanding the Core: Field Line Integration Engine</h2>

                <p>
                    The core of this simulator lies in <scode>compute_field_lines</scode>, a vectorized routine that
                    calculates the trajectory of electric field lines by summing the interactions from all
                    point charges at each integration step. This simulates the path that a positive or a negative test particle would follow under electrostatic forces.
                </p>

                <pre><code class="python">@njit(parallel=True, fastmath=True)
def compute_field_lines(...):
    for i in prange(ORIGINS_COUNT):
        ...
        for j in range(DEPTH):
            fx = fy = 0.0
            for c in range(CHARGES_COUNT):
                dx = px - charge_x[c]
                dy = py - charge_y[c]
                r2 = dx**2 + dy**2 + 1e-12
                f = q[c] / (r2 * sqrt(r2))
                fx += dx * f
                fy += dy * f
        ...
    return lines, lengths, colors</code></pre>

                <img src="../../../assets/images/projects/electric_field/electric_field_screenshot_2025_06_02_23_12_42.webp" alt="Basic Field Line Trajectory"  class="project-image"/>
                
                <h2>üìê Euler Integration Scheme</h2>
                <p>
                    The algorithm uses <strong>explicit forward Euler integration</strong>:
                </p>
                
                <pre><code class="python">px += fx / norm * STEP
py += fy / norm * STEP</code></pre>
                    
                <p>
                    Each field line is advanced in discrete steps along the normalized direction of the electric field.
                    The smaller the <scode>STEP</scode>, the more accurate (and computationally expensive) the result.
                </p>
                    
                <img src="../../../assets/images/projects/electric_field/electric_field_screenshot_2025_06_02_23_25_42.webp" alt="Euler Step Visualization"  class="project-image"/>
                
                <p>
                    When the <scode>STEP</scode> value is set too high (e.g., <scode>STEP = 0.04</scode>), the integration "jumps" over the charge boundaries, causing field lines to miss collisions and bounce erratically. This results in spiky, unrealistic trajectories that never terminate on charges as expected. For best results, use a smaller <scode>STEP</scode> (recommended: <scode>STEP = 0.005</scode>), which ensures smooth, accurate field lines that properly connect to charges.
                </p>
                
                <h2>üí° Field Vector Computation</h2>
                <p>
                    At each step, the electric field is calculated by summing Coulomb forces from all charges:
                </p>
                <p>
                    The electric field <scode><strong>&#x1D435;</strong></scode> at a point <scode><strong>r</strong></scode> due to <scode><strong>N</strong></scode> point charges is given by:
                </p>
                <span class="equation">
                    $$ \vec{E}(\vec{r}) = \sum_{i=1}^{N} q_i \frac{\vec{r} - \vec{r}_i}{|\vec{r} - \vec{r}_i|^3} $$
                </span>
                <pre><code class="python">fx = fy = 0.0
for c in range(CHARGES_COUNT):
    dx = px - charge_x[c]
    dy = py - charge_y[c]
    r2 = dx * dx + dy * dy + 1e-12
    f = q[c] / (r2 * sqrt(r2))
    fx += dx * f * polarity
    fy += dy * f * polarity</code></pre>
                    
                    <p>
                        Here, the field contribution from each charge decays with <scode>1/r¬≤</scode>, and the direction is normalized by <scode>1/r¬≥</scode>.
                        The tiny constant <scode>1e-12</scode> avoids division by zero.
                    </p>
                    
                <img src="../../../assets/images/projects/electric_field/example.webp" alt="Vector Summation from Charges"  class="project-image"/>
                
                <h3>üß† Early Termination Conditions</h3>
                <p>
                    Each line can be interrupted early under specific conditions:
                </p>
                <ul>
                    <li>‚ö†Ô∏è <strong>Collision with opposite charge:</strong> particle enters a charge's radius with opposite sign.</li>
                    <li>üåÄ <strong>Field too weak:</strong> if <scode>norm &lt; 1e-2</scode>, the line stagnates and is terminated.</li>
                    <li>üñ•Ô∏è <strong>Screen edge:</strong> if <scode>cut_on_edge</scode> is <scode>True</scode> and the line exits the screen bounds.</li>
                </ul>
                
                <img src="../../../assets/images/projects/electric_field/electric_field_screenshot_2025_06_02_23_50_45.webp" alt="Line Stopping Scenarios"  class="project-image"/>

                <p>
                    In this example, <scode>cut_on_edge</scode> is enabled, so field lines are terminated as soon as they reach the screen border. This can cause long, re-entering lines to stop abruptly at the edge.
                </p>

                <p> 
                    If you use <em>advanced color mode</em> (gradient between red and blue), the simulator treats the screen border as a valid endpoint, which may result in incorrect color fading at the line ends. For the most accurate visualization when <em>cut on edge</em> is active, it‚Äôs recommended to use <em>low spec mode</em> for field line colors.
                </p>

                <h2>‚öôÔ∏è Parameters and Their Effects</h2>
                <h3>Simulation Parameters and Main Variables</h3>
                <ul class="param-list">
                    <li>
                        <strong><scode>SCREEN_SIZE</scode></strong>: <br>
                        <span class="desc">Vector2D object representing the screen resolution (e.g., <scode>V2(1920, 1080)</scode>).</span>
                        <span class="effect">Affects all geometric calculations and rendering.</span>
                    </li>
                    <li>
                        <strong><scode>SCREEN_SIZE_X</scode>, <scode>SCREEN_SIZE_Y</scode></strong>: <br>
                        <span class="desc">Width and height extracted from <scode>SCREEN_SIZE</scode>.</span>
                        <span class="effect">Used for mapping normalized positions to pixels.</span>
                    </li>
                    <li>
                        <strong><scode>CHARGES_PROBABILITY_FUNC</scode></strong>: <br>
                        <span class="desc"><a href="https://www.desmos.com/calculator/o96rfcqrgu" target="_blank" style="color: var(--primary-color-dark-shade-1);">Custom lambda function</a> to skew the distribution of charge positions for more interesting setups.</span>
                        <!-- <iframe src="https://www.desmos.com/calculator/6vrqhyiruq?embed" width="500" height="500" style="border: 1px solid #ccc" frameborder=0></iframe> -->
                        <span class="effect">Clusters charges at visually/physically interesting locations.</span>
                    </li>
                    <li>
                        <strong><scode>ORIGINS_COUNT</scode></strong>: <br>
                        <span class="desc">Number of field line starting points (seeds).</span>
                        <span class="effect">More lines = more visual detail, but heavier computation.</span>
                    </li>
                    <li>
                        <strong><scode>DEPTH</scode></strong>: <br>
                        <span class="desc">Maximum number of steps per field line.</span>
                        <span class="effect">Higher values allow longer lines but slow performance.</span>
                    </li>
                    <li>
                        <strong><scode>STEP</scode></strong>: <br>
                        <span class="desc">Step size in Euler integration.</span>
                        <span class="effect">Smaller values give smoother curves but increase computation.</span>
                    </li>
                    <li>
                        <strong><scode>ORBS_STEP</scode></strong>: <br>
                        <span class="desc">Steps per orb per frame.</span>
                        <span class="effect">Controls orb update frequency and smoothness.</span>
                    </li>
                    <li>
                        <strong><scode>MAX_ORBS_LIFETIME</scode></strong>: <br>
                        <span class="desc">Maximum orb lifetime in seconds.</span>
                        <span class="effect">Limits how long orbs persist in the simulation.</span>
                    </li>
                    <li>
                        <strong><scode>CHARGES_VALUES</scode></strong>: <br>
                        <span class="desc">Array of point charge magnitudes (e.g., <scode>[-1.0, 1.0, -1.0]</scode>).</span>
                        <span class="effect">Defines the strength and polarity of each charge.</span>
                    </li>
                    <li>
                        <strong><scode>CHARGES_COUNT</scode></strong>: <br>
                        <span class="desc">Total number of point charges.</span>
                        <span class="effect">Affects the complexity of the field.</span>
                    </li>
                    <li>
                        <strong><scode>CHARGES_UNIT_POSITIONS_XS</scode>, <scode>CHARGES_UNIT_POSITIONS_YS</scode></strong>: <br>
                        <span class="desc">Normalized (0‚Äì1) positions for charges on X and Y axes.</span>
                        <span class="effect">Determines where charges are placed before mapping to pixels.</span>
                    </li>
                    <li>
                        <strong><scode>CHARGES_POSITIONS_XS</scode>, <scode>CHARGES_POSITIONS_YS</scode></strong>: <br>
                        <span class="desc">Pixel coordinates for charge positions.</span>
                        <span class="effect">Used for rendering and physics calculations.</span>
                    </li>
                    <li>
                        <strong><scode>REAL_CHARGES_RADIUS</scode></strong>: <br>
                        <span class="desc">Radius (in pixels) of each charge for drawing and collision.</span>
                        <span class="effect">Affects visual size and collision detection.</span>
                    </li>
                    <li>
                        <strong><scode>REAL_ORBS_RADIUS</scode></strong>: <br>
                        <span class="desc">Radius of orbs in the simulation.</span>
                        <span class="effect">Affects orb rendering.</span>
                    </li>
                    <li>
                        <strong><scode>INITIAL_CUT_ON_EDGE</scode></strong>: <br>
                        <span class="desc">Whether to stop field lines at the screen edge.</span>
                        <span class="effect">If true, lines are cropped at the border; if false, they may wrap or continue off-screen.</span>
                    </li>
                </ul>

                <h2>üß™ Example Situations and Diagnostics</h2>
                <p>
                    The following examples illustrate typical configurations and anomalies:
                </p>
                <ul>
                    <li><strong>Dipole System:</strong> One positive and one negative charge. Lines go from + to ‚àí in smooth arcs.
                        <video controls poster="../../../assets/images/projects/electric_field/electric_field_screenshot_2025_06_03_01_56_20.webp" class="project-video">
                            <source src="../../../assets/videos/projects/electric_field/dipole.webm" type="video/webm">
                            Your browser does not support the video tag.
                        </video>
                    </li>
                    <li><strong>Quad Charges (Alternating):</strong> Four charges placed at the corners of a square, alternating positive and negative. This creates a symmetric, intricate field pattern with lines weaving between charges.
                        <video controls poster="../../../assets/images/projects/electric_field/electric_field_screenshot_2025_06_03_01_53_54.webp" class="project-video">
                            <source src="../../../assets/videos/projects/electric_field/quad_charges.webm" type="video/webm">
                            Your browser does not support the video tag.
                        </video>
                    </li>
                    <li>
                        <strong>Central Positive with Negative Ring:</strong> One positive charge (+10) at the center, surrounded by 10 negative charges (‚àí1) evenly spaced in a circle. This creates a "sunburst" pattern where field lines radiate outward from the center and curve sharply toward the surrounding negatives.
                        <pre><code class="python">CHARGES_VALUES = np.array([10.0, ] + [-1.0] * 10, dtype=np.float64)
# Array of point charge magnitudes (in arbitrary units).

CHARGES_COUNT = CHARGES_VALUES.size  # 11
# Total number of point charges in the simulation.

# ---------------------- CHARGE POSITIONING ---------------------- #
# Center in pixel coordinates
center_x = SCREEN_SIZE.x / 2
center_y = SCREEN_SIZE.y / 2

# Radius of the circular distribution (in pixels)
R = min(SCREEN_SIZE) * .4

# Angles for 10 surrounding charges
angles = np.linspace(0, 2 * np.pi, 10, endpoint=False)
ring_xs = center_x + R * np.cos(angles)
ring_ys = center_y + R * np.sin(angles)

# Combine central and ring charges
CHARGES_POSITIONS_XS = np.concatenate(([center_x], ring_xs))
CHARGES_POSITIONS_YS = np.concatenate(([center_y], ring_ys))

# CHARGES_UNIT_POSITIONS_XS/YS are optional if not needed later
CHARGES_UNIT_POSITIONS_XS = CHARGES_POSITIONS_XS / SCREEN_SIZE.x
CHARGES_UNIT_POSITIONS_YS = CHARGES_POSITIONS_YS / SCREEN_SIZE.y</code></pre>
                        <video controls poster="../../../assets/images/projects/electric_field/electric_field_screenshot_2025_06_03_02_08_11.webp" class="project-video">
                            <source src="../../../assets/videos/projects/electric_field/10_1.webm" type="video/webm">
                            Your browser does not support the video tag.
                        </video>
                    </li>
                    <li>
                        <strong>Stationary Point Demonstration:</strong> Using the same "10 negative charges in a ring + 1 positive center" setup, you can create a <em>stationary point</em> (where the net electric field is zero) by carefully placing additional charges. In the simulator, use <kbd>F</kbd> and <kbd>G</kbd> to add positive and negative orbs at various positions. When placed near the stationary point, these orbs will remain nearly motionless, visually confirming the field's equilibrium at that location.
                        <video controls poster="../../../assets/images/projects/electric_field/electric_field_screenshot_2025_06_03_02_13_12.webp" class="project-video">
                            <source src="../../../assets/videos/projects/electric_field/stationary.webm" type="video/webm">
                            Your browser does not support the video tag.
                        </video>
                        <p>
                            Note: Areas without visible field lines do not indicate the absence of an electric field. Instead, this is a limitation of the visualization: only a finite number of field lines can be traced and rendered. The density of field lines in the simulation is determined by the number and placement of starting points (origins), not by the actual field strength at every location. In regions with high field line density, fewer lines may appear elsewhere, but the underlying field is present everywhere‚Äîjust not always visualized.
                        </p>
                    </li>
                </ul>

                <h2>üîç Field Lines Function</h2>
                <p>
                    The core function <scode>compute_field_lines</scode> computes the field lines for a set of origins, using a forward Euler integration scheme. It is optimized using Numba for parallel computation and fast math.
                </p>
                <pre><code class="python"># ---------------------- FIELD LINE COMPUTATION ---------------------- #
@njit(parallel=True, fastmath=True)
def compute_field_lines(origins_xs: np.ndarray,
                        origins_ys: np.ndarray,
                        charge_positions_xs: np.ndarray,
                        charge_positions_ys: np.ndarray,
                        charge_magnitudes: np.ndarray,
                        origin_values: np.ndarray,
                        cut_on_edge: bool
                    ) -> tuple[np.ndarray, np.ndarray, np.ndarray]:
    """
    Computes electric field lines for a set of origins, using a forward Euler integration scheme.
    Optimized using Numba for parallel computation and fast math.

    Parameters:
        - origins_xs, origins_ys: 1D arrays of normalized starting points for field lines (range [0,1])
        - charge_positions_xs, charge_positions_ys: 1D arrays of normalized coordinates of point charges
        - charge_magnitudes: 1D array of scalar charge magnitudes (signed)
        - origin_values: 1D array of +1 or -1 values indicating field line polarity (direction)
        - cut_on_edge: if True, stops field lines when they exit the screen boundary

    Returns:
        - lines: (ORIGINS_COUNT, DEPTH, 2) array containing the 2D trajectory of each field line
        - lengths: (ORIGINS_COUNT,) array with the actual computed length (number of steps) per line
        - colors: (ORIGINS_COUNT, DEPTH, 3) array of RGB colors for each segment, for fade/visual effect
    """

    # Allocate memory for the output arrays
    lines = np.empty((ORIGINS_COUNT, DEPTH, 2), dtype=np.float64)   # Stores coordinates of the field lines
    lengths = np.empty(ORIGINS_COUNT, dtype=np.int32)               # Stores the number of valid steps per line
    colors = np.empty((ORIGINS_COUNT, DEPTH, 3), dtype=np.uint8)    # Stores RGB color for visual fading

    # Minimum field magnitude below which the line is considered to have terminated (field too weak)
    min_norm = 1e-2

    # Loop over each starting point (field line origin) in parallel
    for i in prange(ORIGINS_COUNT):
        # Initialize particle position (normalized coordinates in [0,1])
        px, py = origins_xs[i], origins_ys[i]
        polarity = origin_values[i]  # +1 or -1, determines direction of integration
        length = DEPTH               # Default full length unless terminated earlier

        # Iterate over max steps allowed (DEPTH)
        for j in range(DEPTH):
            fx = fy = 0.0            # Accumulated field vector components
            stop = False             # Whether to terminate this line early (e.g., collision)

            # Accumulate electric field contribution from each charge
            for c in range(CHARGES_COUNT):
                dx = px - charge_positions_xs[c]
                dy = py - charge_positions_ys[c]
                r2 = dx * dx + dy * dy + 1e-12       # Add epsilon to avoid division by zero
                r2_normalized = dx * dx + dy * dy    # Normalized squared distance (no epsilon)

                # Terminate field line if it's inside a charge (within visible radius) and opposite polarity
                # This is a collision check: if the particle is within the charge radius and has opposite polarity
                if (r2_normalized < REAL_RADIUS_SQRD_CONTEXT) and (polarity * charge_magnitudes[c] < 0):
                    stop = True
                    break

                # Electric field magnitude using Coulomb‚Äôs law: k*q / r^2, but we normalize r^3 for direction
                f = charge_magnitudes[c] / (r2 * np.sqrt(r2))
                fx += dx * f * polarity  # Multiply by polarity to flip direction if needed
                fy += dy * f * polarity

            # Compute norm of the resulting electric field vector
            norm = np.sqrt(fx * fx + fy * fy)

            # Check if integration should stop (weak field or collision)
            if stop or norm < min_norm:
                length = j
                lines[i, j:, 0] = px  # Fill remaining points with the last known position
                lines[i, j:, 1] = py
                break

            # Move the particle a single step in the direction of the field (Euler step)
            px += fx / norm * STEP
            py += fy / norm * STEP

            # Store the new position
            lines[i, j, 0] = px
            lines[i, j, 1] = py

            # Optional early termination if the line exits the screen (in normalized coordinates)
            if cut_on_edge and (px < 0 or px > 1 or py < 0 or py > SCREEN_SIZE_Y / SCREEN_SIZE_X):
                length = j
                lines[i, j:, 0] = px
                lines[i, j:, 1] = py
                break

        # Store actual computed length for this line
        lengths[i] = length if length < DEPTH else DEPTH

        # Compute color fading along the field line for rendering
        # Red-to-blue gradient depending on polarity and distance from origin
        for j in range(lengths[i]):
            di = 1 - j / lengths[i]  # Linear interpolation factor (1 at start, 0 at end)

            if polarity > 0:
                # Fade from red (head) to blue (tail)
                colors[i, j, 0] = int(255 * di)           # Red
                colors[i, j, 1] = 0                       # Green
                colors[i, j, 2] = int(255 * (1 - di))     # Blue
            else:
                # Fade from blue (head) to red (tail)
                colors[i, j, 0] = int(255 * (1 - di))     # Red
                colors[i, j, 1] = 0                       # Green
                colors[i, j, 2] = int(255 * di)           # Blue

    # Return pixel-space coordinates (multiply by screen width), actual lengths, and color gradients
    return lines * SCREEN_SIZE_X, lengths, colors</code></pre>

                <p>
                    This function is the heart of the simulation, computing the trajectory of each field line based on the electric field generated by all point charges. It uses Numba for performance, allowing real-time updates and rendering.
                </p>
                
                <h2>üß© Main Simulation Class: Input & State Handling</h2>
                <p>
                    The <scode>Env</scode> class is the main simulation environment. It manages the state of all charges, field lines, orbs, and user input. This class handles resetting, updating, and rendering the simulation, as well as processing keyboard and mouse events for interactive control. All simulation logic, including dragging charges, toggling modes, and animating orbs, is encapsulated here for a responsive and interactive experience.
                </p>
                <p>
                    <p>
                        <em>Installation:</em> To run this simulation, install the required <scode>e2D</scode> module with:
                    </p>
                    <pre><code class="bash">pip install e2D==1.4.20</code></pre>
                    <p>
                        This version is tested and verified for compatibility with the electric field simulator.
                    </p>
                    <p>
                        You will also need <scode>numba</scode> and <scode>numpy</scode>:
                    </p>
                    <pre><code class="bash">pip install --upgrade numba numpy</code></pre>
                </p>

                <pre><code class="python">class Env(DefEnv):
    def __init__(self) -> None:
        """Initialize the simulation environment and draw the first frame."""
        # Initialize empty arrays to store field lines and their lengths
        self.lines = np.empty((ORIGINS_COUNT, DEPTH, 2), dtype=np.float64)
        self.line_lengths = np.empty(ORIGINS_COUNT, dtype=np.int32)

        # Store the polarity (+1/-1) for each field line origin
        self.origins_values = np.empty(ORIGINS_COUNT, dtype=np.int8)

        # Store RGB color data for each point on every field line
        self.line_colors = np.empty((ORIGINS_COUNT, DEPTH, 3), dtype=np.float32)

        # Determines whether lines should be truncated at the screen edge
        self.cut_on_edge = INITIAL_CUT_ON_EDGE

        # Toggle display of control instructions on screen
        self.show_keybinds = False

        # Toggle between simple or advanced color styling for field lines
        self.advanced_lines_colors = True

        # Stores last mode used to place field line origins (0 = random, 1 = near charges)
        self.last_origins_randomization = 1

        # Create an off-screen surface for rendering the field
        self.surface = pg.Surface(rootEnv.screen_size())

        # Initialize charge data and field line origins
        self.reset_charges(False)
        self.reset_origins(True)

        # List of temporary orbs placed by user (position, sign, spawn time)
        self.orbs : list[tuple[Vector2D, Literal[1, -1], float]] = []

        # Create transparent surface for keybind instructions
        self.keybinds_surf = pg.Surface(rootEnv.screen_size(), pg.SRCALPHA, 32).convert_alpha()

        # List of control instructions displayed to user
        labels = [
            "quit | X or alt+F4       ",
            "move selected charge | LEFT CLICK + DRAG ",
            "select charge | LEFT CLICK        ",
            "change selected charge value by 0.1 | UP/DOWN ARROW     ",
            "change selected charge value by 1 | RIGHT/LEFT ARROW  ",
            "toggle keybinds | Q  ",
            "toggle cut line on screen edge | W  ",
            "reset field lines origins randomly | E  ",
            "reset field lines origins around positive charges | R  ",
            "reset charges to start positions | T  ",
            "reset charges to random positions | Y  ",
            "randomize charges values | A  ",
            "take screenshot | S  ",
            "toggle advanced line colors (LOW SPEC MODE)| D  ",
            "add positive charged orb at mouse position | F  ",
            "add negative charged orb at mouse position | G  ",
        ]

        # Render keybind labels to the surface
        for i, label in enumerate(labels):
            rootEnv.print(label,
                          rootEnv.screen_size.mult(y=0) + V2(0, 40 * i),
                          pivot_position="top_right",
                          color=WHITE_COLOR_PYG,
                          margin=V2(10, 10),
                          font=TEXT_FONT,
                          bg_color=BLACK_COLOR_PYG,
                          border_radius=10,
                          personalized_surface=self.keybinds_surf)

    def reset_charges(self, update: bool = True) -> None:
        """Reset charges to their default positions and values."""
        # Deselect any currently selected charge
        self.selected_charge_index = -1
        self.last_selected = -1

        # Copy default charge values and positions
        self.charges_values = CHARGES_VALUES.copy()
        self.charges_positions_xs = CHARGES_POSITIONS_XS.copy()
        self.charges_positions_ys = CHARGES_POSITIONS_YS.copy()

        # Optionally update field line origins as well
        if update:
            self.reset_origins(True)

    def reset_origins_random(self, update: bool = True) -> None:
        """Place field line origins randomly on screen with polarity based on charge ratios."""
        # Place origins at random (x, y) positions on screen
        self.origins_xs = np.random.uniform(-1, 1, ORIGINS_COUNT)
        self.origins_ys = np.random.uniform(-1, 1, ORIGINS_COUNT)

        # Assign polarity according to the ratio of positive charges
        positive_charges_ratio = np.sum(self.charges_values > 0) / CHARGES_COUNT
        self.origins_values = np.random.choice([1, -1], size=ORIGINS_COUNT, p=[positive_charges_ratio, 1 - positive_charges_ratio]).astype(np.int8)

        # Record the randomization mode used
        self.last_origins_randomization = 0

        # Optionally update field lines after randomization
        if update:
            self.update_lines()

    def reset_origins(self, update: bool = True) -> None:
        """Distribute field line origins near charges proportionally to their |magnitude|."""
        abs_mags = np.abs(self.charges_values)
        total = np.sum(abs_mags)
        
        if total == 0:
            # Fallback to uniform distribution if all charges are 0
            weights = np.ones(CHARGES_COUNT) / CHARGES_COUNT
        else:
            weights = abs_mags / total

        # Compute number of origins per charge based on weights
        origins_per_charge = np.floor(weights * ORIGINS_COUNT).astype(np.int32)
        assigned = np.sum(origins_per_charge)
        remainder = ORIGINS_COUNT - assigned

        # Distribute remaining origins to the charges with largest fractional parts
        if remainder > 0:
            fractional = (weights * ORIGINS_COUNT) - origins_per_charge
            top_indices = np.argsort(fractional)[-remainder:]
            origins_per_charge[top_indices] += 1

        # Create indices array with the charge index repeated accordingly
        indices = np.repeat(np.arange(CHARGES_COUNT), origins_per_charge)

        # Shuffle to avoid visible banding artifacts
        np.random.shuffle(indices)

        # Store indices of the associated charges
        self.origins_attached_indices = indices
        self.origins_values = np.sign(self.charges_values[indices]).astype(np.int8)

        # Spread the origins around each charge slightly randomly
        angles = np.random.uniform(0, 2 * np.pi, ORIGINS_COUNT)
        # radii = np.random.uniform(REAL_CHARGES_RADIUS * .9, REAL_CHARGES_RADIUS * 1.1, ORIGINS_COUNT)
        dx = np.cos(angles) * REAL_CHARGES_RADIUS * .75
        dy = np.sin(angles) * REAL_CHARGES_RADIUS * .75

        self.origins_xs = self.charges_positions_xs[indices] + dx
        self.origins_ys = self.charges_positions_ys[indices] + dy
        self.last_origins_randomization = 1

        if update:
            self.update_lines()

    def draw(self) -> None:
        """Render the environment on screen, including orbs and optionally keybinds."""
        # Blit simulation surface to screen
        rootEnv.screen.blit(self.surface, (0, 0))

        # Draw all active orbs with their time-to-live
        for orb_pos, orb_charge, orb_time in self.orbs:
            pg.draw.circle(rootEnv.screen,
                           RED_COLOR_PYG if orb_charge > 0 else BLUE_COLOR_PYG,
                           orb_pos(),
                           REAL_ORBS_RADIUS)
            pg.draw.circle(rootEnv.screen,
                           WHITE_COLOR_PYG,
                           orb_pos(),
                           REAL_ORBS_RADIUS,
                           int(REAL_ORBS_RADIUS / 5))
            rootEnv.print(
                f"{max(0, MAX_ORBS_LIFETIME - rootEnv.runtime_seconds + orb_time):.2f} s",
                orb_pos.sub(y=REAL_ORBS_RADIUS * 1.5),
                pivot_position="bottom_center",
                color=TEXT_COLOR_1,
                font=TEXT_FONT
            )

        # Optionally draw the keybinds UI
        if self.show_keybinds:
            rootEnv.screen.blit(self.keybinds_surf, (0, 0))

    def render(self) -> None: 
        self.surface.fill(BLACK_COLOR_PYG)  # Clear the surface with a black background
        """This function renders everything: field lines, charges, and UI text."""

        # Draw each electric field line
        for line, length, colors in zip(self.lines, self.line_lengths, self.line_colors):
            masked_line = line[:length]  # Trim the line to its actual drawn length

            if self.advanced_lines_colors:
                # If using color gradients, draw each segment with its corresponding color
                masked_colors = colors[:length]
                for i in range(1, len(masked_line)):
                    pg.draw.aaline(self.surface, masked_colors[i], masked_line[i - 1], masked_line[i])
            else:
                # Draw a single-colored polyline
                pg.draw.aalines(self.surface, FIELD_LINE_COLOR, False, masked_line)

        # Draw each point charge
        for i, (value, pos_x, pos_y) in enumerate(zip(self.charges_values, self.charges_positions_xs, self.charges_positions_ys)):
            # Determine color by sign: red for positive, blue for negative, white for zero
            color = RED_COLOR_PYG if value > 0 else (BLUE_COLOR_PYG if value < 0 else WHITE_COLOR_PYG)

            # Draw the main circle of the charge
            pg.draw.circle(self.surface, color, (pos_x, pos_y), REAL_CHARGES_RADIUS,
                        int(REAL_CHARGES_RADIUS / 5) if i == self.selected_charge_index else 0)

            # Highlight the charge with a white ring if it was the last one clicked
            if i == self.last_selected:
                pg.draw.circle(self.surface, WHITE_COLOR_PYG, (pos_x, pos_y), REAL_CHARGES_RADIUS / 5)

            # Display the numeric value of the charge below it
            rootEnv.print(str(round(value, 3)), V2(pos_x, pos_y - REAL_CHARGES_RADIUS * 1.25),
                        pivot_position="bottom_center", font=TEXT_FONT, personalized_surface=self.surface)

            # Draw an outer white border for visibility
            pg.draw.circle(self.surface, WHITE_COLOR_PYG, (pos_x, pos_y), REAL_CHARGES_RADIUS, int(REAL_CHARGES_RADIUS / 9))

        # Show a bottom-centered text with the keybind help message
        rootEnv.print("press Q to view keybinds", rootEnv.screen_size.mult(x=.5),
                    pivot_position="bottom_center", color=TEXT_COLOR_1,
                    margin=V2(0, 10), font=TEXT_FONT, personalized_surface=self.surface)

    def update_lines(self) -> None:
        """Recompute all electric field lines based on the current configuration."""
        self.lines[:], self.line_lengths[:], self.line_colors[:] = compute_field_lines(
            self.origins_xs / SCREEN_SIZE_X,
            self.origins_ys / SCREEN_SIZE_X,
            self.charges_positions_xs / SCREEN_SIZE_X,
            self.charges_positions_ys / SCREEN_SIZE_X,
            self.charges_values,
            self.origins_values,
            self.cut_on_edge
        )
        self.render()  # Update visual display

    def update(self) -> None:
        """Handle input from user and update simulation accordingly."""

        # Toggle keybind visibility
        if rootEnv.keyboard.get_key(pg.K_q, "just_pressed"):
            self.show_keybinds = not self.show_keybinds

        # Toggle edge-cutting for field lines
        if rootEnv.keyboard.get_key(pg.K_w, "just_pressed"):
            self.cut_on_edge = not self.cut_on_edge
            self.update_lines()

        # Reset origins to random positions
        if rootEnv.keyboard.get_key(pg.K_e, "just_pressed"):
            self.reset_origins_random()

        # Reset origins around positive charges
        if rootEnv.keyboard.get_key(pg.K_r, "just_pressed"):
            self.reset_origins()

        # Reset all charges to their default configuration
        if rootEnv.keyboard.get_key(pg.K_t, "just_pressed"):
            self.reset_charges()

        # Randomize charge positions using the distribution function
        if rootEnv.keyboard.get_key(pg.K_y, "just_pressed"):
            self.charges_positions_xs = CHARGES_PROBABILITY_FUNC(np.random.uniform(0, 1, CHARGES_COUNT)) * 2 - 1
            self.charges_positions_ys = CHARGES_PROBABILITY_FUNC(np.random.uniform(0, 1, CHARGES_COUNT)) * 2 - 1
            self.reset_origins()

        # Randomize charge values between -10 and 10
        if rootEnv.keyboard.get_key(pg.K_a, "just_pressed"):
            self.charges_values = np.random.uniform(-10, 10, CHARGES_COUNT)
            self.reset_origins()

        # Save screenshot of the current field
        if rootEnv.keyboard.get_key(pg.K_s, "just_pressed"):
            self.take_screenshot()

        # Toggle field line color gradient
        if rootEnv.keyboard.get_key(pg.K_d, "just_pressed"):
            self.advanced_lines_colors = not self.advanced_lines_colors
            self.render()

        # Add a positive charged orb at the mouse position
        if rootEnv.keyboard.get_key(pg.K_f, "just_pressed"):
            self.orbs.append((rootEnv.mouse.position, 1, rootEnv.runtime_seconds))

        # Add a negative charged orb at the mouse position
        if rootEnv.keyboard.get_key(pg.K_g, "just_pressed"):
            self.orbs.append((rootEnv.mouse.position, -1, rootEnv.runtime_seconds))

        # Select a charge with left mouse click
        if rootEnv.mouse.get_key(0, "just_pressed"):
            selected_one = False
            for i, (charge_x, charge_y) in enumerate(zip(self.charges_positions_xs, self.charges_positions_ys)):
                if rootEnv.mouse.position.distance_to(Vector2D(charge_x, charge_y), False) < REAL_RADIUS_SQRD:
                    selected_one = True
                    self.last_selected = i
                    self.selected_charge_index = i
                    break
            if not selected_one:
                self.selected_charge_index = -1
                self.render()
        elif rootEnv.mouse.get_key(0, "just_released"):
            self.selected_charge_index = -1  # Stop dragging

        # If a charge is selected, allow changing its value using arrows
        if self.last_selected != -1:
            last_selected_value_sign = np.sign(self.charges_values[self.last_selected])

            if rootEnv.keyboard.get_key(pg.K_UP, "pressed"):
                self.charges_values[self.last_selected] = round(self.charges_values[self.last_selected] + .1, 2)
                self.update_lines()

            if rootEnv.keyboard.get_key(pg.K_DOWN, "pressed"):
                self.charges_values[self.last_selected] = round(self.charges_values[self.last_selected] - .1, 2)
                self.update_lines()

            if rootEnv.keyboard.get_key(pg.K_RIGHT, "pressed"):
                self.charges_values[self.last_selected] = round(self.charges_values[self.last_selected] + 1, 2)
                self.update_lines()

            if rootEnv.keyboard.get_key(pg.K_LEFT, "pressed"):
                self.charges_values[self.last_selected] = round(self.charges_values[self.last_selected] - 1, 2)
                self.update_lines()

            if rootEnv.keyboard.get_key(pg.K_LEFT, "just_released") or rootEnv.keyboard.get_key(pg.K_RIGHT, "just_released") or \
               rootEnv.keyboard.get_key(pg.K_UP, "just_released") or rootEnv.keyboard.get_key(pg.K_DOWN, "just_released"):
                self.reset_origins()
                self.update_lines()

            # If the sign of the selected charge changed, update the corresponding origins
            if last_selected_value_sign != np.sign(self.charges_values[self.last_selected]):
                self.origins_values[self.origins_attached_indices == self.last_selected] = \
                    np.sign(self.charges_values[self.last_selected]).astype(np.int8)

        # Animate orbs over time by computing electric force steps
        for i, (orb_pos, orb_charge, orb_time) in enumerate(self.orbs):
            if rootEnv.runtime_seconds - orb_time > MAX_ORBS_LIFETIME:
                self.orbs.pop(i)  # Remove expired orb
            else:
                stop = False
                for orb_step in range(ORBS_STEP):
                    fx = fy = 0.0
                    for c in range(CHARGES_COUNT):
                        dx = (orb_pos.x - self.charges_positions_xs[c]) / SCREEN_SIZE_X
                        dy = (orb_pos.y - self.charges_positions_ys[c]) / SCREEN_SIZE_X
                        r2 = dx * dx + dy * dy + 1e-12
                        r2_normalized = dx * dx + dy * dy

                        if (r2_normalized < REAL_RADIUS_SQRD_CONTEXT) and (orb_charge * self.charges_values[c] < 0):
                            stop = True
                            break

                        f = self.charges_values[c] / (r2 * np.sqrt(r2))
                        fx += dx * f * orb_charge
                        fy += dy * f * orb_charge
                    
                    if stop:
                        break

                    norm = np.sqrt(fx * fx + fy * fy)
                    orb_pos.x += fx / norm
                    orb_pos.y += fy / norm
                
                if stop:
                    # If the orb was stopped by a charge, remove it
                    self.orbs.pop(i)

        # Drag selected charge with mouse
        if self.selected_charge_index != -1:
            new_x = rootEnv.mouse.position.x
            new_y = rootEnv.mouse.position.y

            delta_x = new_x - self.charges_positions_xs[self.selected_charge_index]
            delta_y = new_y - self.charges_positions_ys[self.selected_charge_index]

            # Only act if there's real movement
            if delta_x != 0 or delta_y != 0:
                self.charges_positions_xs[self.selected_charge_index] = new_x
                self.charges_positions_ys[self.selected_charge_index] = new_y

                if self.last_origins_randomization == 1:
                    mask = self.origins_attached_indices == self.selected_charge_index
                    self.origins_xs[mask] += delta_x
                    self.origins_ys[mask] += delta_y

                self.update_lines()  # Recompute field

    def take_screenshot(self) -> None:
        """Capture a screenshot of the current simulation state."""
        timestamp = datetime.now().strftime("%Y_%m_%d_%H_%M_%S")
        pg.image.save(rootEnv.screen, f"electric_field_screenshot_{timestamp}.png")</code></pre>

                <div class="centered-button">
                    <a href="https://github.com/marick-py/python/blob/1d2c64e33f44bc9c7a3a85ef2c103a7a31d71c41/prog(236)_(electric_field)/electric_field_(V2_no_ratio).py"
                    class="button" target="_blank">
                    üîó View Project on GitHub
                    </a>
                </div>
                <div id="chat-system">
                    <script src="https://giscus.app/client.js"
                    data-repo="marick-py/emptyhead.dev"
                    data-repo-id="R_kgDOOaqypg"
                    data-category="General"
                    data-category-id="DIC_kwDOOaqyps4CpKFf"
                    data-mapping="url"
                    data-strict="0"
                    data-reactions-enabled="1"
                    data-emit-metadata="0"
                    data-input-position="top"
                    data-theme="dark"
                    data-lang="en"
                    data-loading="lazy"
                    crossorigin="anonymous"
                    async>
                    </script>
                </div>
            </div>
        </section>


		<!-- Footer -->
		<footer class="top-footer">
			<div class="social-links">
				<a href="https://discord.com/users/589449750382903315" target="_blank"><i class="fa fa-discord"></i></a>
				<a href="https://github.com/marick-py" target="_blank"><i class="fa fa-github"></i></a>
				<a href="https://stackoverflow.com/users/15393950/marick" target="_blank"><i class="fa fa-stack-overflow"></i></a>
				<a href="https://www.linkedin.com/in/mariani-riccardo" target="_blank"><i class="fa fa-linkedin"></i></a>
				<a href="mailto:ricomari2006@gmail.com" target="_blank"><i class="fa fa-envelope"></i></a>
				<a href="http://instagram.com/m.rikk_" target="_blank"><i class="fa fa-instagram"></i></a>
			</div>
		</footer>
		
		<footer class="bottom-footer">
			<div class="footer-content">
				<ul class="footer-links">
					<li><a href="policy_terms.html">Privacy Policy</a></li>
					<li><a href="policy_terms.html">Terms of Use</a></li>
					<li><button class="footer-contact-button">Contact Us</button></li>
				</ul>
				<p>&copy; <span id="year"></span> emptyhead.dev. All rights reserved.</p>
			</div>
		</footer>

		<script src="../../../assets/js/main.js"></script>
		<script src="../../../assets/js/counter.js" type="module"></script>
        <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js" async></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
        <script>
            document.addEventListener("DOMContentLoaded", function() {
                hljs.highlightAll();
            });
        </script>
    </body>

</html>